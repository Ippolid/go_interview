# Выжимка статьи: Generics в Go

Источник: https://kodikapusta.ru/articles/generics

## Зачем нужны дженерики
- До Go 1.18 общий код часто дублировали под каждый тип (`int`, `float64`, `string` и т.д.).
- Альтернатива через `interface{}` убирала часть типобезопасности и делала код менее удобным.
- Дженерики позволяют писать один алгоритм для разных типов и сохранять проверку типов на этапе компиляции.

## Базовый синтаксис
- Параметры типа объявляются в `[]`:

```go
func F[T any](p T) {}

type Box[T any] struct {
	v T
}
```

- `any` - это синоним `interface{}`.
- Тип можно указать явно или положиться на вывод типов компилятором:

```go
Print[int](42)  // явное указание
Print("hello")  // type inference
```

## Ограничения (constraints)
- У каждого параметра типа есть ограничение:

```go
func Do[T Constraint](v T) {}
```

- Ограничения задаются интерфейсами типов и определяют, какие операции доступны внутри функции.
- Пример: если внутри нужен `String()`, ограничение должно требовать этот метод, `any` уже не подойдет:

```go
type Stringer interface {
	String() string
}

func ToText[T Stringer](v T) string {
	return v.String()
}
```

## Полезные предопределенные ограничения
- `comparable`: типы, которые можно сравнивать через `==` и `!=` (важно для ключей `map`).
- Union-ограничения через `|`:

```go
type Number interface {
	int64 | float64
}
```

- Можно использовать приближение `~` для базового типа:

```go
type MyInt interface {
	~int
}
```

Подходят типы, у которых базовый тип `int`.

## Что обычно обобщают дженериками
- Числовые операции (`Sum`, `Double`, `DotProduct`).
- Утилиты для слайсов (`Map`, `Reduce`, `Filter`, `Merge`, `Sort`, `Includes`).
- Утилиты для `map` (`Keys`, `Sum`).
- Типовые структуры данных:

```go
type Set[T comparable] map[T]struct{}
```