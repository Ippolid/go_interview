# Паттерны конкурентности в Go

Здесь собраны основные паттерны для работы с горутинами и каналами. Каждый паттерн решает конкретную задачу при параллельной обработке данных.

---

## 1. Fan-In (Объединение каналов)

**Файл:** `fanInOrMergeChannels.go`

### Что делает?

Объединяет несколько каналов в один. Представьте, что у вас 3 источника данных (например, 3 сервера отправляют логи), и вы хотите читать все логи из одного места.

### Как работает?

```
Канал 1 ──┐
Канал 2 ──┼──> Объединенный канал ──> Обработка
Канал 3 ──┘
```

Функция запускает горутину для каждого входного канала. Каждая горутина читает данные из своего канала и отправляет их в общий выходной канал.

### Когда использовать?

- Нужно собрать данные из нескольких источников в одно место
- Несколько горутин генерируют результаты, а обрабатывать их хотите в одном месте
- Агрегация логов, метрик, событий

### Пример использования

```go
// Создаем 3 источника данных
server1 := generateLogs("Server-1")
server2 := generateLogs("Server-2")
server3 := generateLogs("Server-3")

// Объединяем в один канал
allLogs := FanInOrMergeChannels(server1, server2, server3)

// Читаем все логи из одного места
for log := range allLogs {
    fmt.Println("Получен лог:", log)
}
```

### Важно

- Выходной канал закрывается автоматически, когда все входные каналы закрыты
- Порядок сообщений не гарантируется
- Потокобезопасно - можно использовать из разных горутин

---

## 2. Fan-Out (Распределение задач)

**Файл:** `fan_out.go`

### Что делает?

Берет задачи из одного канала и распределяет их между несколькими воркерами для параллельной обработки. Результаты от всех воркеров собираются обратно в один канал.

### Как работает?

```
              ┌──> Воркер 1 ──┐
Задачи ───>───┼──> Воркер 2 ──┼───> Результаты
              └──> Воркер 3 ──┘
```

Запускается N воркеров, каждый читает задачи из общего канала. Кто первый свободен - тот и берет следующую задачу. Все результаты отправляются в один выходной канал.

### Когда использовать?

- Много однотипных задач, которые нужно обработать быстро
- Задачи независимы друг от друга
- Есть тяжелые вычисления, которые можно распараллелить
- Нужно ускорить обработку большого количества данных

### Пример использования

```go
// Канал с 100 задачами
jobs := make(chan int, 100)
for i := 1; i <= 100; i++ {
    jobs <- i
}
close(jobs)

// Запускаем 5 воркеров для обработки
results := FanOut(5, jobs)

// Получаем обработанные результаты
for result := range results {
    fmt.Println("Обработано:", result)
}
```

### Важно

- Количество воркеров = параллелизм (5 воркеров = максимум 5 задач одновременно)
- Канал результатов закрывается автоматически после обработки всех задач
- Каждая задача обрабатывается ровно один раз

---

## 3. Worker Pool (Пул воркеров)

**Файл:** `workerpool.go`

### Что делает?

Создает фиксированное количество воркеров, которые постоянно ждут новые задачи. Это как бригада рабочих - они не создаются для каждой задачи, а работают постоянно, пока есть работа.

### Как работает?

```
Submit() ──> Очередь задач ──> Воркер 1 ──┐
Submit() ──>                   Воркер 2 ──┼──> Результаты
Submit() ──>                   Воркер 3 ──┘
```

1. Создается пул с N воркерами
2. Воркеры запускаются через `Start()`
3. Задачи добавляются через `Submit()`
4. Воркеры берут задачи из очереди и обрабатывают
5. Результаты отправляются в канал результатов
6. `Stop()` закрывает очередь и ждет завершения всех задач

### Когда использовать?

- Нужен контроль над количеством параллельных операций
- Задачи поступают постоянно (не все сразу)
- Хотите переиспользовать горутины вместо создания новых
- Нужно ограничить нагрузку на систему
- Важно собирать ошибки от выполненных задач

### Пример использования

```go
// Создаем пул из 3 воркеров
pool := NewWorkerPool(3)
pool.Start()

// Запускаем чтение результатов
done := make(chan struct{})
go func() {
    for result := range pool.Results() {
        if result.Error != nil {
            log.Println("Ошибка:", result.Error)
        } else {
            log.Println("Успешно выполнено")
        }
    }
    close(done)
}()

// Отправляем задачи
for i := 0; i < 100; i++ {
    taskID := i
    pool.Submit(func() error {
        // Ваша работа
        return processTask(taskID)
    })
}

// Завершаем работу
pool.Stop()
<-done // Ждем обработки всех результатов
```

### Важно

- **Обязательно** читайте результаты в отдельной горутине ДО вызова `Stop()`
- Канал задач и результатов буферизованы для избежания блокировок
- `Stop()` дожидается завершения всех запущенных задач
- Подходит для long-running процессов

---

## 4. Semaphore (Семафор)

**Файл:** `semaphore.go`

### Что делает?

Ограничивает количество одновременно выполняющихся операций. Работает как турникет - пропускает только N человек одновременно, остальные ждут в очереди.

### Как работает?

```
Горутина 1 ──> Acquire() ──> [Выполняется] ──> Release()
Горутина 2 ──> Acquire() ──> [Выполняется] ──> Release()
Горутина 3 ──> Acquire() ──> [Выполняется] ──> Release()
Горутина 4 ──> Acquire() ──> [Ждет...    ]
```

Семафор имеет ограничение (например, 3). Когда горутина вызывает `Acquire()`, она:
- Проходит сразу, если есть свободные слоты
- Блокируется и ждет, если все слоты заняты

Когда задача завершена, вызывается `Release()` - освобождается слот для следующей горутины.

### Когда использовать?

- Ограничение запросов к внешнему API (например, максимум 10 запросов в секунду)
- Контроль подключений к базе данных
- Ограничение параллельных операций с файлами
- Защита от перегрузки внешних сервисов

### Пример использования

```go
// Создаем семафор на 5 одновременных операций
sem := NewSemaphore(5)

var wg sync.WaitGroup
for i := 0; i < 100; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        
        sem.Acquire()           // Ждем свободный слот
        defer sem.Release()     // Освобождаем слот после завершения
        
        // Только 5 горутин одновременно выполнят это
        makeAPIRequest(id)
    }(i)
}

wg.Wait()
```

### Важно

- **Всегда** используйте `defer sem.Release()` после `Acquire()`
- Это гарантирует освобождение слота даже при панике
- Семафор можно переиспользовать многократно
- Размер семафора = максимальное количество параллельных операций

---

## Сравнение паттернов

| Паттерн | Зачем нужен | Сколько горутин | Управление |
|---------|-------------|-----------------|------------|
| **Fan-In** | Объединить несколько источников данных | По горутине на каждый входной канал | Автоматическое |
| **Fan-Out** | Распределить работу между воркерами | Указываете количество воркеров | Автоматическое |
| **Worker Pool** | Постоянный пул для обработки задач | Фиксированное (указываете при создании) | Start/Stop вручную |
| **Semaphore** | Ограничить количество параллельных операций | Неограниченно, но работают только N одновременно | Acquire/Release вручную |

---